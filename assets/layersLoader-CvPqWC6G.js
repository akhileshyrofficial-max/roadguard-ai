import{s as y,p as F,ax as M}from"./Identifiable-B58w9FD1.js";import{t as g,n as P}from"./fetchService-CoDeYCDA.js";import{o as $,u as G,s as m,l as x,e as I,y as k,c as b,i as D,a as w}from"./loadUtils-Bp82eUcj.js";import{H as v,A as C,G as A}from"./layerUtils-CAMu1s-2.js";import{e as L}from"./jsonContext-Bav6E5DB.js";import{s as E}from"./portalItemUtils-LGbTNR1x.js";import{t as j}from"./styleUtils-oTRUAnZN.js";import"./index-VFfT8Aji.js";import"./associatedFeatureServiceUtils-BN0GHEhP.js";import"./PortalItem-DLsR4Y2a.js";import"./projectionUtils-DsK_8mH5.js";import"./asyncUtils-C5b0g4Vr.js";async function ue(t,o){const a=t.instance.portalItem;if(a!=null&&a.id)return await a.load(o),O(t),t.validateItem&&t.validateItem(a),R(t,o)}function O(t){const o=t.instance.portalItem;if(!(o!=null&&o.type)||!t.supportedTypes.includes(o.type))throw new y("portal:invalid-layer-item-type","Invalid layer item type '${type}', expected '${expectedType}'",{type:o==null?void 0:o.type,expectedType:t.supportedTypes.join(", ")})}async function R(t,o){const a=t.instance,e=a.portalItem;if(!e)return;let{url:l}=e;const{title:r}=e,s=L(e,"portal-item");if(a.type==="group")return J(a,s,t);l&&a.type!=="media"&&a.read({url:l},s);const u=new I,{data:p,preferredHost:n}=await S(t,u,o);return l=e.url,"isUrlHostModified"in a&&(n?a.applyPreferredHost({preferredHost:n}):a.applyHostFromPortalItem()),p&&a.read(p,s),a.resourceReferences={portalItem:e,paths:s.readResourcePaths??[]},a.type!=="subtype-group"&&a.read({title:r},s),j(a,s)}async function J(t,o,a){const e=t.portalItem;if(!t.sourceIsPortalItem)return;const{title:l,type:r}=e;if(r==="Group Layer"){if(!E(e,"Map"))throw new y("portal:invalid-layer-item-typekeyword","'Group Layer' item without 'Map' type keyword is not supported");return N(t,a)}return t.read({title:l},o),V(t,a)}async function N(t,o){const a=t.portalItem,e=await a.fetchData("json");if(!e)return;if(!o.populateGroupLayer)throw new y("portal:missing-populate-group-layer","Missing populate group layer");const l=L(a,"web-map");t.read(e,l),await o.populateGroupLayer(t,e,{context:l}),t.resourceReferences={portalItem:a,paths:l.readResourcePaths??[]}}async function V(t,o){var c;let a;const{portalItem:e}=t;if(!e)return;const l=e.type,r=o.layerModuleTypeMap;if(!r)throw new y("portal:missing-layer-module-type-map","Layer module type map is required to construct sub layers");switch(l){case"Feature Service":case"Feature Collection":a=r.FeatureLayer;break;case"Stream Service":a=r.StreamLayer;break;case"Scene Service":a=r.SceneLayer;break;case"Video Service":a=r.VideoLayer;break;default:throw new y("portal:unsupported-item-type-as-group",`The item type '${l}' is not supported as a 'IGroupLayer'`)}const s=l==="Video Service",u=new I;let[p,{data:n}]=await Promise.all([a(),s?{data:null}:S(o,u)]),i=()=>p;if(s)return q(t,i,r);if(l==="Feature Service"){const f=(c=m(n))==null?void 0:c.customParameters;n=e.url?(await x(n,e.url,u)).data:{},i=await X(n,r)||i;const{provider:T,preferredHost:H}=await W(e.url,{customParameters:f,loadContext:u});return v(e,H),await d(t,i,i,n,r,T)}return l==="Scene Service"&&e.url&&(n=await k(e,n,u)),b(n)>0?await d(t,i,null,n,r):await U(t,i,r)}async function U(t,o,a){var r,s;const{portalItem:e}=t;if(!(e!=null&&e.url))return;const l=await g(e.url);l&&d(t,o,null,{layers:(r=l.layers)==null?void 0:r.map(w),tables:(s=l.tables)==null?void 0:s.map(w)},a)}async function q(t,o,a){var r;const{portalItem:e}=t;if(!(e!=null&&e.url))return;const l=await g(e.url);l&&d(t,o,null,{layers:(r=l.layers)==null?void 0:r.map(({id:s,name:u})=>({id:s,name:u}))},a)}async function d(t,o,a,e,l,r){var p;let s=e.layers||[];const u=e.tables||[];if(((p=t.portalItem)==null?void 0:p.type)==="Feature Collection"?(s.forEach((n,i)=>{var c;n.id=i,((c=n==null?void 0:n.layerDefinition)==null?void 0:c.type)==="Table"&&u.push(n)}),s=s.filter(n=>{var i;return((i=n==null?void 0:n.layerDefinition)==null?void 0:i.type)!=="Table"})):(s.reverse(),u.reverse()),s.forEach(n=>{const i=r==null?void 0:r(n);if(i||!r){const c=h(t,o(n),e,n,i);t.add(c)}}),u.length){const n=a?null:await l.FeatureLayer();u.forEach(i=>{const c=r==null?void 0:r(i);if(c||!r){const f=h(t,a?a(i):n,e,i,c);t.tables.add(f)}})}}function h(t,o,a,e,l){const r=t.portalItem,s={portalItem:r.clone(),layerId:e.id};e.url!=null&&(s.url=e.url);const u=new o(s);if("sourceJSON"in u&&(u.sourceJSON=l),u.type!=="subtype-group"&&u.type!=="catalog"&&(u.sublayerTitleMode="service-name"),r.type==="Feature Collection"){const p={origin:"portal-item",portal:r.portal||M.getDefault()};u.read(e,p);const n=a.showLegend;n!=null&&u.read({showLegend:n},p)}return u}async function S(t,o,a){if(t.supportsData===!1)return{data:void 0};const e=t.instance,l=e.portalItem;if(!l)return{data:void 0};let r=null;try{r=await l.fetchData("json",a)}catch{}if(K(e)){let s=null;const{count:u,preferredHost:p}=await z(l,r,o);if(v(l,p),((r==null?void 0:r.layers)||(r==null?void 0:r.tables))&&u>0){if(e.layerId==null){const n=$(e.type),i=n!=null&&n.length?G(r,n)[0]:m(r);i&&(e.layerId=i.id)}s=B(r,e),(s==null?void 0:s.layerType)==="OrientedImageryLayer"&&e.type==="oriented-imagery"&&e.supportedSourceTypes.add("Feature Layer"),s&&r.showLegend!=null&&(s.showLegend=r.showLegend)}return u>1&&"sublayerTitleMode"in e&&e.sublayerTitleMode!=="service-name"&&(e.sublayerTitleMode="item-title-and-service-name"),{data:s,preferredHost:p}}return{data:r}}async function z(t,o,a){var s,u,p,n,i;if(o!=null&&o.layers&&(o!=null&&o.tables))return{count:b(o)};const e=F(t.url);if(!e)return{count:1};const l=e.url.path,r=await a.fetchServiceMetadata(l,{customParameters:(s=m(o))==null?void 0:s.customParameters}).catch(()=>null);return{count:(((u=o==null?void 0:o.layers)==null?void 0:u.length)??((p=r==null?void 0:r.layers)==null?void 0:p.length)??0)+(((n=o==null?void 0:o.tables)==null?void 0:n.length)??((i=r==null?void 0:r.tables)==null?void 0:i.length)??0),preferredHost:A(t)?C():null}}function B(t,o){var l,r;const{layerId:a}=o,e=((l=t.layers)==null?void 0:l.find(s=>s.id===a))||((r=t.tables)==null?void 0:r.find(s=>s.id===a));return e&&Q(e,o)?e:null}function K(t){return t.type!=="stream"&&"layerId"in t}function Q(t,o){const a="layerType"in t&&t.layerType,{type:e}=o;return!(e==="feature"&&a&&t.layerType!=="ArcGISFeatureLayer"||e==="catalog"&&!a||e==="oriented-imagery"&&!a||e==="subtype-group"&&!a)}async function W(t,o){const{layersJSON:a,preferredHost:e}=await P(t,o);if(!a)return{provider:null,preferredHost:e};const l=[...a.layers,...a.tables];return{provider:r=>l.find(s=>s.id===r.id),preferredHost:e}}async function X(t,o){const{layers:a,tables:e}=t,l=[...a??[],...e??[]];if(!l.length)return;const r=new Set,s=[];for(const{layerType:n}of l){const i=n??"ArcGISFeatureLayer";if(r.has(i))continue;r.add(i);const c=o[D(i)];s.push(c())}const u=await Promise.all(s),p=new Map;return Array.from(r).forEach((n,i)=>{p.set(n,u[i])}),({layerType:n})=>{const i=n??"ArcGISFeatureLayer";return p.get(i)}}export{ue as load};
