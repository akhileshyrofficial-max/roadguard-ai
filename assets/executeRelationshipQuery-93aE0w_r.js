import{f as u}from"./utils-C83x6Enz.js";import{H as f,ct as y}from"./Identifiable-BjM0PfdN.js";import{t as j}from"./query-DotrZ5xP.js";import{g as R}from"./FeatureSet-CfhGyZLm.js";import{c as d}from"./labelingInfo-D4BqM-rK.js";import"./index-CVvIVqY1.js";import"./jsonUtils-DBuABSQZ.js";import"./normalizeUtils-DfEBCyY7.js";import"./normalizeUtilsCommon-Bp_cDVNc.js";import"./utils-CFSOSud-.js";import"./pbfQueryUtils-h97YwSQw.js";import"./pbf-nAs1algh.js";import"./memoryEstimations-m6Z1UQ7X.js";import"./OptimizedFeature-DwEGrxrA.js";import"./OptimizedFeatureSet-BR8EEvDc.js";import"./queryZScale-4dT8HLv_.js";import"./projectionUtils-D3_kHwH-.js";import"./Graphic-C2Bnzy89.js";import"./PopupTemplate-CF36_3mn.js";import"./fieldUtils-Br-fPSxS.js";import"./typeUtils-U-Zf11cK.js";import"./createFeatureId-BiB9j2WD.js";import"./typeUtils-CP9PJ8Sp.js";import"./SimpleMarkerSymbol-D-X_CJ8B.js";import"./screenUtils-aQeO9QTD.js";import"./aaBoundingBox-BrXqvn3i.js";import"./TextSymbol-DPyc43q3.js";import"./PictureMarkerSymbol-DOPylmLK.js";import"./Field-FVkerAtx.js";import"./fieldType-ClovGbuQ.js";import"./asyncUtils-zc5DpkIL.js";import"./uuid-Cl5lrJ4c.js";import"./Query-duJofNa2.js";import"./Layer-CUjb8Y3m.js";import"./layerUtils-CmDKJw7q.js";import"./SimpleRenderer-DtNv2-NG.js";import"./commonProperties-DMnf_yWT.js";import"./colorRamps-BRrX9yVq.js";import"./ColorStop-5uJISB8q.js";import"./visualVariableUtils-D9hF7KBy.js";import"./lengthUtils-BDJ7rNGW.js";import"./jsonUtils-0dtnZsjW.js";import"./defaults3D-BGxlF4_A.js";import"./defaults-DZVYugxa.js";import"./defaultsJSON-GKolV7NZ.js";import"./UniqueValueRenderer-B64Ao_xz.js";import"./diffUtils-B0wxD3C_.js";import"./RendererLegendOptions-Dm8mjmQN.js";import"./styleUtils-qogXp5hy.js";import"./NormalizationBinParametersMixin-Crnd6wMH.js";import"./labelUtils-NFOL2PSf.js";function h(e,o){const t=e.toJSON();return t.objectIds&&(t.objectIds=t.objectIds.join(",")),t.orderByFields&&(t.orderByFields=t.orderByFields.join(",")),t.outFields&&!(o!=null&&o.returnCountOnly)?t.outFields.includes("*")?t.outFields="*":t.outFields=t.outFields.join(","):delete t.outFields,t.outSR&&(t.outSR=y(t.outSR)),t.dynamicDataSource&&(t.layer=JSON.stringify({source:t.dynamicDataSource}),delete t.dynamicDataSource),t}async function F(e,o,t){const i=await l(e,o,t),r=i.data,n=r.geometryType,m=r.spatialReference,p={};for(const s of r.relatedRecordGroups){const a={fields:void 0,geometryType:n,spatialReference:m,hasZ:!!r.hasZ,hasM:!!r.hasM,features:s.relatedRecords};if(s.objectId!=null)p[s.objectId]=a;else for(const c of Object.keys(s))c!=="relatedRecords"&&(p[s[c]]=a)}return{...i,data:p}}async function b(e,o,t){const i=await l(e,o,t,{returnCountOnly:!0}),r=i.data,n={};for(const m of r.relatedRecordGroups)m.objectId!=null&&(n[m.objectId]=m.count);return{...i,data:n}}async function l(e,o,t={},i){const r=j({...e.query,f:"json",...i,...h(o,i)});return f(e.path+"/queryRelatedRecords",{...t,query:{...t.query,...r}})}async function ht(e,o,t){o=d.from(o);const i=u(e);return F(i,o,t).then(r=>{const n=r.data,m={};return Object.keys(n).forEach(p=>m[p]=R.fromJSON(n[p])),m})}async function Ft(e,o,t){o=d.from(o);const i=u(e);return b(i,o,{...t}).then(r=>r.data)}export{ht as executeRelationshipQuery,Ft as executeRelationshipQueryForCount};
