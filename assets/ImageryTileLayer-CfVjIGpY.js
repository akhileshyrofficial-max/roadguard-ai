const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/imageryUtils-v-XKdPbN.js","assets/utils-DLby0kF6.js","assets/Identifiable-_3rFZ1o6.js","assets/index-BEHHhRxI.js","assets/originUtils-D69mHv66.js","assets/multiOriginJSONSupportUtils-C0wm8_Yw.js","assets/PortalItem-Dn4oT_Gd.js","assets/jsonContext-DKFyyNwn.js","assets/portalItemUtils-CHuQGePU.js","assets/projectionUtils-BdqPecQc.js","assets/saveUtils-2gkpyGz5.js","assets/rasterFieldUtils-BbQcz_gX.js","assets/Field-Bopg3Spw.js","assets/fieldType-Pks4G8In.js"])))=>i.map(i=>d[i]);
import{_ as Ae}from"./index-BEHHhRxI.js";import{al as A,a3 as W,aS as Be,cA as Le,c as R,m as C,d as Y,w as Fe,s as F,L as Se,fv as Je,b5 as ze,aB as Ue,aY as He,I as je,a0 as V,i as ge,ad as Ge,cs as We,E as qe,b0 as Ve,l as Ye}from"./Identifiable-_3rFZ1o6.js";import{q as Xe}from"./PopupTemplate-B09IYibB.js";import{S as Ke}from"./MultiOriginJSONSupport-uq7YIQYP.js";import{h as Ze}from"./Layer--GugXUPW.js";import{l as Qe}from"./ArcGISService-vS49SR2m.js";import{p as et}from"./BlendLayer-DNv82dbV.js";import{e as tt}from"./CustomParametersMixin-BZBJ7Ucu.js";import{$ as Z,i as fe,t as U,n as ke,e as L,o as q,u as se,X as st,m as it}from"./xmlUtilities-COtR5Svh.js";import{b as rt,d as at}from"./OperationalLayer-Dmy6sOtR.js";import{j as nt}from"./PortalLayer-DgoCliAY.js";import{d as ot,N as Me}from"./RasterJobHandlerMixin-DBPBxlWR.js";import{c as lt,f as ct,o as ut}from"./RasterPresetRendererMixin-B2A0gGI8.js";import{f as ft}from"./RefreshableLayer-DF_vXnzd.js";import{t as pt}from"./ScaleRangeLayer-5c4AXGq9.js";import{c as ht}from"./TemporalLayer-YoR144NV.js";import{m as Te}from"./Field-Bopg3Spw.js";import{p as mt,N as dt,o as gt,c as yt,e as wt,j as xt,$ as It,b as bt,k as vt,l as St,r as Tt,t as Rt}from"./rasterFieldUtils-BbQcz_gX.js";import{c as ae,i as _t,R as Ot,I as Ct,B as Ft}from"./dataUtils-Dr5KRzjN.js";import{m as le,p as kt,h as Pe,g as we,P as Mt,l as xe,r as Pt,b as Re,W as Nt,C as $t,G as Et,e as _e,H as Dt,t as At,N as Oe,k as Bt,U as Lt}from"./RasterSymbolizer-Dc3ArwNG.js";import{g as Ne}from"./FeatureSet-CZLo56w_.js";import{m as Ie,n as Jt}from"./PolynomialTransform-gGC_3BAQ.js";import{j as ne}from"./TileInfo-CvSYzqJL.js";import{T as zt}from"./TilemapCache-CJF5zmes.js";import{w as Ut,T as Ht}from"./rasterFunctionHelper-6S1OmDnr.js";import{p as jt}from"./popupUtils-aSReiMof.js";import{A as ie}from"./interfaces-CL2NbQte.js";import"./fieldUtils-z3GG2R-H.js";import"./layerContainerType-C5CzMsLd.js";import"./jsonUtils-CO8m00ps.js";import"./parser-BgHAYnRY.js";import"./screenUtils-aQeO9QTD.js";import"./mat4f32-Djp3mnm5.js";import"./mat4-CEszlm-2.js";import"./common-DQOJ18NT.js";import"./QueueProcessor-BZCvf8_s.js";import"./Queue-CJjQn74K.js";import"./ReactiveMap-DptZZMoQ.js";import"./signal-R7pX2aet.js";import"./RawBlockCache-b0wY4EX8.js";import"./rasterProjectionHelper-BWJ4uK2N.js";import"./projectionUtils-BdqPecQc.js";import"./clipUtils-CEFueasy.js";import"./ElevationInfo-7Ug8ElGs.js";import"./lengthUtils-CrwfL9_h.js";import"./asyncUtils-CmphLL3n.js";import"./layerUtils-CFmFO8Du.js";import"./PortalItem-Dn4oT_Gd.js";import"./portalItemUtils-CHuQGePU.js";import"./jsonUtils-Cc67rW5Z.js";import"./ClassBreaksRenderer-zodgNWUT.js";import"./commonProperties-CEA2GgpB.js";import"./colorRamps-BmQEv1lz.js";import"./ColorStop-DY3WB4ha.js";import"./visualVariableUtils-DciVTowe.js";import"./Graphic-q_7OAYHf.js";import"./typeUtils-mxDsOnhk.js";import"./createFeatureId-BiB9j2WD.js";import"./typeUtils-Buir9u-w.js";import"./SimpleMarkerSymbol-Drowg4jp.js";import"./aaBoundingBox-DNlIzH5i.js";import"./TextSymbol-keZwKiPd.js";import"./PictureMarkerSymbol-DlgeV3xL.js";import"./jsonUtils-MHL9p1Rq.js";import"./defaults3D-CE2uGgSa.js";import"./defaults-CSNv9gRz.js";import"./defaultsJSON-GKolV7NZ.js";import"./RendererLegendOptions-DWy2dLCX.js";import"./UniqueValueRenderer-CBLY0uWW.js";import"./diffUtils-C5CsICXC.js";import"./styleUtils-D7bnZHs6.js";import"./workers-BcCT7nhd.js";import"./intl-Beb5GWXc.js";import"./number-7p_O6jwX.js";import"./normalizeUtils-BS0bJnzn.js";import"./normalizeUtilsCommon-Ca72SEzL.js";import"./utils-C73sopP7.js";import"./utils-UVgDzRJn.js";import"./utils-BeNGKuUJ.js";import"./cimSymbolUtils-B2Z2xZbf.js";import"./utils-DrbBeUzW.js";import"./defaultCIMValues-BrbaHf9c.js";import"./enums-BPiq_WIC.js";import"./LRUCache-eBEVKbNU.js";import"./MemCache-CUhFgUMJ.js";import"./ClassBreaksDefinition-BJIhW5Q8.js";import"./TimeInfo-Bt4YU_aA.js";import"./timeZoneUtils-Cef7SfoB.js";import"./fieldType-Pks4G8In.js";import"./_commonjsHelpers-DCkdB7M8.js";import"./colorUtils-DQQagumJ.js";import"./vec42-CKs01hkn.js";import"./vec4f64-DPb6J-GU.js";import"./TileKey-DZd6gJy7.js";import"./ByteSizeUnit-BsxeN7wM.js";import"./memoryEstimations-BG_NSMOj.js";function $e(s){return["x","e","east","long","longitude"].includes(s.toLowerCase())}function Ee(s){return["y","n","west","lat","latitude"].includes(s.toLowerCase())}function Gt(s){const{axes:e}=s.domain,t=Object.keys(e),i=[],r=[];let a=-1,n=-1,c=[];for(let y=0;y<t.length;y++){const S=t[y];$e(S)?a=y:Ee(S)&&(n=y);const v=e[S],x=[];if("values"in v){v.values.forEach(I=>x.push(typeof I=="string"?new Date(I).getTime():I));const T=x[1]-x[0];i.push([x[0]-.5*T,x[x.length-1]+.5*T]),r.push(T)}else{const{start:T,stop:I,num:O}=v,b=(I-T)/(O-1);i.push([T-.5*b,I+.5*b]),r.push(b);for(let k=0;k<O;k++)x.push(T+b*k)}c.push({name:S,values:x,extent:[x[0],x[x.length-1]]})}a>-1&&n===-1?n=a===0?1:0:n>-1&&a===-1?a=n===0?1:0:n===-1&&a===-1&&(a=0,n=1),c=c.filter((y,S)=>!(S===a||S===n));const{referencing:l}=s.domain,o=l.find(y=>y.coordinates.includes(t[a])).system.id,u=o==null?void 0:o.slice(o.lastIndexOf("/")+1),p=u==null||u==="CRS84"?4326:Number(u),f=new A({wkid:p}),[h,w]=i[a],[d,m]=i[n],g=new W({xmin:h,xmax:w,ymin:d,ymax:m,spatialReference:f});return{width:Math.round(g.width/r[a]),height:Math.round(g.height/r[n]),extent:g,dimensions:c}}function pe(s){var t;const e=(t=Le())==null?void 0:t.language;return e?s[e]??Object.values(s)[0]:Object.values(s)[0]}function he(){return Math.round(255*Math.random())}function Wt(s){var i,r;const e={},{parameters:t}=s;if(!t)return e;for(const[a,n]of Object.entries(t)){const{type:c,description:l,unit:o,categoryEncoding:u,observedProperty:p}=n;if(c==="Parameter"&&(e[a]={},l&&(e[a].description=pe(l)),o&&(e[a].unit=o.label?pe(o.label):null,e[a].symbol=(i=o.symbol)==null?void 0:i.value),u)){const f=Object.entries(u).map((d,m)=>({OID:m,Value:Number(d[1]),ClassName:d[0].slice(d[0].lastIndexOf("/")+1),Count:1}));let h=!1;(r=p==null?void 0:p.categories)!=null&&r.length&&(p.categories.forEach(d=>{if(!d.id)return;const m=d.id.slice(d.id.lastIndexOf("/")+1),g=f.find(S=>S.ClassName===m);if(!g)return;const y=d.label?pe(d.label):null;if(g.Label=y,d.preferredColor){const S=Be.fromHex(d.preferredColor);S&&(h=!0,g.Red=S.r,g.Green=S.g,g.Blue=S.b)}}),h&&f.forEach(d=>{d.Red==null&&(d.Red=he(),d.Green=he(),d.Blue=he())}));const w={objectIdFieldName:"",fields:[{name:"OID",type:"esriFieldTypeOID",alias:"OID",domain:null},{name:"Value",type:"esriFieldTypeInteger",alias:"Value",domain:null},{name:"Count",type:"esriFieldTypeDouble",alias:"Count",domain:null},{name:"ClassName",type:"esriFieldTypeString",alias:"ClassName",domain:null,length:50},{name:"Label",type:"esriFieldTypeString",alias:"Label",domain:null,length:50}],features:f.map(d=>({attributes:d}))};h&&w.fields.push({name:"Red",type:"esriFieldTypeInteger",alias:"Red",domain:null},{name:"Green",type:"esriFieldTypeInteger",alias:"Green",domain:null},{name:"Blue",type:"esriFieldTypeInteger",alias:"Blue",domain:null}),e[a].attributeTable=w}}return e}function qt(s){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE;for(let i=0;i<s.length;i++){const r=s[i];r!=null&&(r<e&&(e=r),r>t&&(t=r))}return _t(e,t)}function Vt(s,e,t){const i=s.map((l,o)=>({name:l,count:e[o]})).sort((l,o)=>l.name>o.name?-1:1),r=(a=1,l=>a*=l.count);var a;const n=[...i.slice(1),{name:"",count:1}].reverse().map(r).reverse();let c=0;for(let l=s.length-1;l>=0;l--)c+=n[i.findIndex(({name:o})=>o===s[l])]*(t%e[l]),t=Math.floor(t/e[l]);return c}function Yt(s){var f;const{width:e,height:t,extent:i,dimensions:r}=Gt(s),{ranges:a}=s,n=Object.keys(a).sort((h,w)=>h<w?-1:1),c=[];for(let h=0;h<n.length;h++){const w=n[h];r!=null&&r.length&&c.push({name:w,dimensions:r})}const l=Wt(s);c.forEach(h=>l[h.name]&&Object.assign(h,l[h.name]));const o=c.length?{variables:c}:void 0,u=[];for(let h=0;h<n.length;h++){const w=n[h],{values:d,dataType:m,axisNames:g,shape:y}=a[w],S=y.length>2?h*y.slice(0,-2).reduce((b,k)=>b*k):0,v=g.slice(0,-2),x=y.slice(0,-2),T=m==="float"?"f32":qt(d),I=e*t,O=d.length/I;for(let b=0;b<O;b++){const k=ae.createEmptyBand(T,I),_=new Uint8Array(I).fill(255);let M=!1;const J=b*I;for(let P=0;P<I;P++){const $=d[J+P];$==null?(_[P]=0,M=!0):k[P]=$}if(h===0||r!=null&&r.length){const P=new ae({width:e,height:t,mask:M?_:null,pixels:[k],pixelType:T});P.updateStatistics(),(r==null?void 0:r.length)?u[Vt(v,x,b)+S]=P:u.push(P)}else{const P=u[b];P.pixels.push(k),M?P.mask&&(P.mask=ae.combineBandMasks([P.mask,_])):P.mask=M?_:null}}}const p=(f=Object.values(l).find(h=>h.attributeTable))==null?void 0:f.attributeTable;return{extent:i,pixelBlocks:u,multidimensionalInfo:o,attributeTable:p,bandNames:o?void 0:n}}let X=class extends Z{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.source=null}get url(){return""}fetchRawTile(s,e,t,i={}){if(!this._pixelBlockTiles){const{rasterInfo:a}=this,[n,c]=a.storageInfo.tileInfo.size,{sliceId:l}=i,{pixelBlocks:o}=this.source,u={pixelBlock:l==null?o[0]:o[l],useBilinear:a.dataType!=="thematic",tileSize:{width:n,height:c},level:s,row:e,col:t},p=this.rasterJobHandler?this.rasterJobHandler.clipTile(u,i):Ot(u);return Promise.resolve(p)}const r=this._pixelBlockTiles.get(`${s}/${e}/${t}`);return Promise.resolve(r)}async _open(s){const e=this.source,{pixelBlocks:t,attributeTable:i,statistics:r,histograms:a,name:n,nativeExtent:c,transform:l}=e,o=t[0],{width:u,height:p,pixelType:f}=o,h=e.extent??new W({xmin:-.5,ymin:.5,xmax:u-.5,ymax:p-.5,spatialReference:new A({wkid:3857})}),w=e.isPseudoSpatialReference??!e.extent,d={x:h.width/u,y:h.height/p},m={...e.keyProperties};i&&(m.DataType="Thematic");const g=new le({width:u,height:p,pixelType:f,extent:h,nativeExtent:c,attributeTable:i,transform:l,pixelSize:d,spatialReference:h.spatialReference,bandCount:o.pixels.length,keyProperties:m,multidimensionalInfo:e.multidimensionalInfo,statistics:r,isPseudoSpatialReference:w,histograms:a});this.ioConfig.skipMapInfo&&this.updateImageSpaceRasterInfo(g),this.createRemoteDatasetStorageInfo(g,512,512),this._set("rasterInfo",g),this.updateTileInfo(),g.multidimensionalInfo?await this._buildMDimStats(e.pixelBlocks,g.multidimensionalInfo):await this._buildInMemoryRaster(o,{width:512,height:512},s),g.multidimensionalInfo||(this.source=null),this.datasetName=n}async _buildInMemoryRaster(s,e,t){var p,f;const{rasterInfo:i}=this,r=i.storageInfo.maximumPyramidLevel??0,a=i.dataType!=="thematic",n=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:s,tileSize:e,maximumPyramidLevel:r,useBilinear:a},t):Promise.resolve(Ct(s,e,r,a)),c=i.statistics!=null,l=i.histograms!=null,o=this.ioConfig.skipStatistics||c?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:s},t):Promise.resolve(kt(s)),u=await Fe([n,o]);if(!u[0].value&&u[1].value)throw new F("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=u[0].value,c||(i.statistics=(p=u[1].value)==null?void 0:p.statistics),l||(i.histograms=(f=u[1].value)==null?void 0:f.histograms)}async _buildMDimStats(s,e,t){for(let i=0;i<e.variables.length;i++){const r=e.variables[i];if(r.statistics)continue;const a=r.dimensions.map(o=>{var u,p;return new mt({variableName:r.name,dimensionName:o.name,values:[((u=o.values)==null?void 0:u[0])??((p=o.extent)==null?void 0:p[0])],isSlice:!0})}),n=dt(a,e),c=n==null?null:s[n];if(c==null)continue;const l=this.rasterJobHandler?await this.rasterJobHandler.computeStatisticsHistograms({pixelBlock:c},t):Pe(c);r.statistics=l.statistics,r.histograms||(r.histograms=l.histograms)}}};R([C({type:String,json:{write:!0}})],X.prototype,"datasetFormat",void 0),R([C()],X.prototype,"source",void 0),R([C()],X.prototype,"url",null),X=R([Y("esri.layers.support.rasterDatasets.InMemoryRaster")],X);const be=X;let Q=class extends Z{constructor(){super(...arguments),this.datasetFormat="CovJSON"}fetchRawTile(e,t,i,r={}){return this._inMemoryRaster.fetchRawTile(e,t,i,r)}async _open(e){const{extent:t,pixelBlocks:i,multidimensionalInfo:r,attributeTable:a,bandNames:n}=await this._fetchData(e),{statistics:c,histograms:l}=Pe(i[0]),o=n==null?void 0:n.map(h=>({BandName:h})),u={DataType:a?"Thematic":r?"Scientific":"Generic",BandProperties:o},p=new be({source:{extent:t,pixelBlocks:i,attributeTable:a?Ne.fromJSON(a):null,multidimensionalInfo:r,statistics:c,histograms:l,keyProperties:u,isPseudoSpatialReference:!1}});await p.open(),this._inMemoryRaster=p;const f=this.source?"":this.url.slice(this.url.lastIndexOf("/")+1);this._set("datasetName",f.slice(0,f.indexOf("."))),this._set("rasterInfo",p.rasterInfo)}async _fetchData(e){var a,n,c,l;const t=this.source??(await this.request(this.url,{signal:e==null?void 0:e.signal})).data,i="imagery-tile-layer:open-coverage-json";if(((a=t.type)==null?void 0:a.toLowerCase())!=="coverage"||((c=(n=t.domain)==null?void 0:n.domainType)==null?void 0:c.toLowerCase())!=="grid")throw new F(i,"Only coverage with Grid domain type is supported");if(!t.ranges)throw new F(i,"Missing ranges in the grid coverage data");if(!((l=t.domain.referencing)!=null&&l.length))throw new F(i,"Missing domain referencing in the grid coverage data");const r=Object.values(t.ranges);for(let o=0;o<r.length;o++){const{axisNames:u,shape:p,type:f,values:h}=r[o];if(!(f.toLowerCase()==="ndarray"&&(h!=null&&h.length)&&(u!=null&&u.length)&&(p!=null&&p.length)))throw new F(i,"Only ranges with valid NdArray, axisNames, shape, and inline values are supported");if(!($e(u[u.length-1])&&Ee(u[u.length-2])))throw new F(i,"Only row-major ordered pixel values are supported. X axis must be the last axis.")}return Yt(t)}};R([C({type:String,json:{write:!0}})],Q.prototype,"datasetFormat",void 0),R([C({constructOnly:!0})],Q.prototype,"source",void 0),Q=R([Y("esri.layers.support.rasterDatasets.CovJSONRaster")],Q);const Xt=Q;function Ce(s,e){if(!s||!e)return null;const t=[];for(let i=0;i<s.length;i++)t.push(s[i]),t.push(e[i]);return t}function Kt(s){const e=L(s,"GeodataXform"),t=ce(q(e,"SpatialReference/WKID")||U(e,"SpatialReference/WKT"));if(e.getAttribute("xsi:type")!=="typens:PolynomialXform")return{spatialReference:t,transform:null};const i=q(e,"PolynomialOrder")??1,r=se(e,"CoeffX/Double"),a=se(e,"CoeffY/Double"),n=se(e,"InverseCoeffX/Double"),c=se(e,"InverseCoeffY/Double"),l=Ce(r,a),o=Ce(n,c);return{spatialReference:t,transform:l&&o&&l.length&&o.length?new Ie({spatialReference:t,polynomialOrder:i,forwardCoefficients:l,inverseCoefficients:o}):null}}function Zt(s){var f;const e=q(s,"NoDataValue"),t=L(s,"Histograms/HistItem"),i=q(t,"HistMin"),r=q(t,"HistMax"),a=q(t,"BucketCount"),n=(f=U(t,"HistCounts"))==null?void 0:f.split("|").map(h=>Number(h));let c,l,o,u;ke(s,"Metadata/MDI").forEach(h=>{const w=Number(h.textContent??h.nodeValue);switch(h.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":c=w;break;case"STATISTICS_MAXIMUM":l=w;break;case"STATISTICS_MEAN":o=w;break;case"STATISTICS_STDDEV":u=w}});const p=q(s,"Metadata/SourceBandIndex");return{noDataValue:e,histogram:n!=null&&n.length&&i!=null&&r!=null?{min:i,max:r,size:a||n.length,counts:n}:null,sourceBandIndex:p,statistics:c!=null&&l!=null?{min:c,max:l,avg:o,stddev:u}:null}}function ce(s){if(!s)return null;let e=Number(s);if(!isNaN(e)&&e!==0)return new A({wkid:e});if(s=String(s).trim(),Je(s))return new A({wkt2:s});const t=s.toUpperCase();if(t.startsWith("COMPD_CS")){if(!t.includes("VERTCS")||!t.includes("GEOGCS")&&!t.startsWith("PROJCS"))return null;const i=t.indexOf("VERTCS"),r=t.indexOf("PROJCS"),a=r>-1?r:t.indexOf("GEOGCS");if(a===-1)return null;const n=s.slice(a,s.lastIndexOf("]",i)+1).trim(),c=s.slice(i,s.lastIndexOf("]")).trim();e=me(n);const l=new A(e?{wkid:e}:{wkt:n}),o=me(c);return o&&(l.vcsWkid=o),l}return t.startsWith("GEOGCS")||t.startsWith("PROJCS")?(e=me(s),new A(e!==0?{wkid:e}:{wkt:s})):null}function me(s){var r;const e=s.replaceAll("]","[").replaceAll('"',"").split("[").map(a=>a.trim()).filter(a=>a!==""),t=e[e.length-1].split(","),i=(r=t[0])==null?void 0:r.toLowerCase();if((i==="epsg"||i==="esri")&&s.endsWith('"]]')){const a=Number(t[1]);if(!isNaN(a)&&a!==0)return a}return 0}function ve(s){var i;if(((i=s==null?void 0:s.documentElement.tagName)==null?void 0:i.toLowerCase())!=="pamdataset")return{};const e={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};s.documentElement.childNodes.forEach(r=>{if(r.nodeType===1){if(fe(r,"SRS")){if(!e.spatialReference){const a=U(r);e.spatialReference=ce(a)}}else if(fe(r,"Metadata"))if(r.getAttribute("domain")==="xml:ESRI"){const{spatialReference:a,transform:n}=Kt(r);e.transform=n,e.spatialReference||(e.spatialReference=a)}else ke(r,"MDI").forEach(a=>e.metadata[a.getAttribute("key")]=U(a));else if(fe(r,"PAMRasterBand")){const a=Zt(r);a.sourceBandIndex!=null&&e.rasterBands[a.sourceBandIndex]==null?e.rasterBands[a.sourceBandIndex]=a:e.rasterBands.push(a)}}});const t=e.rasterBands;if(t.length){const r=!!t[0].statistics;e.statistics=r?t.map(n=>n.statistics).filter(Se):null;const a=!!t[0].histogram;e.histograms=a?t.map(n=>n.histogram).filter(Se):null}return e}let oe=class extends Z{fetchRawTile(s,e,t,i={}){return this._inMemoryRaster.fetchRawTile(s,e,t,i)}async _open(s){const e=await this._fetchData(s);let{spatialReference:t,statistics:i,histograms:r,transform:a}=await this._fetchAuxiliaryData(s);const n=!t;n&&(t=new A({wkid:3857})),r!=null&&r.length&&i==null&&(i=we(r));const{width:c,height:l}=e;let o=new W({xmin:-.5,ymin:.5-l,xmax:c-.5,ymax:.5,spatialReference:t});const u=a?a.forwardTransform(o):o;let p=!0;if(a){const h=a.forwardCoefficients;p=h&&h[1]===0&&h[2]===0,p&&(a=null,o=u)}const f=new be({source:{extent:u,nativeExtent:o,transform:a,pixelBlocks:[e],statistics:i,histograms:r,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:n},ioConfig:{sampling:"closest",skipStatistics:!0}});this.ioConfig.skipMapInfo&&(f.ioConfig.skipMapInfo=!0),await f.open(),f.source=null,this._set("rasterInfo",f.rasterInfo),this._inMemoryRaster=f}async _fetchData(s){const{data:e}=await this.request(this.url,{responseType:"array-buffer",signal:s==null?void 0:s.signal}),t=Mt(e).toUpperCase();if(t!=="JPG"&&t!=="PNG"&&t!=="GIF"&&t!=="BMP")throw new F("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",t);const i=t.toLowerCase(),r=i==="gif"||i==="bmp"||!ze("ios"),a=await this.decodePixelBlock(e,{format:i,useCanvas:r,hasNoZlibMask:!0});if(a==null)throw new F("image-aux-raster:open","the data cannot be decoded");return a}async _fetchAuxiliaryData(s){var u;const e=s==null?void 0:s.signal,{skipExtensions:t=[],skipMapInfo:i}=this.ioConfig,r=i||t.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:e}),a=this.datasetFormat,n=a==="JPG"?"jgw":a==="PNG"?"pgw":a==="BMP"?"bpw":null,c=n&&t.includes(n)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+n,{responseType:"text",signal:e}),l=await Fe([r,c]);if(e!=null&&e.aborted)throw Ue();const o=ve((u=l[0].value)==null?void 0:u.data);if(!o.transform){const p=l[1].value?l[1].value.data.split(`
`).slice(0,6).map(f=>Number(f)):null;o.transform=(p==null?void 0:p.length)===6?new Ie({forwardCoefficients:[p[4],p[5],p[0],-p[1],p[2],-p[3]]}):null}return o}};R([C({type:String,json:{write:!0}})],oe.prototype,"datasetFormat",void 0),oe=R([Y("esri.layers.support.rasterDatasets.ImageAuxRaster")],oe);const re=oe;let ee=class extends Z{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async fetchRawTile(s,e,t,i={}){var J;const{storageInfo:r,extent:a}=this.rasterInfo,{transposeInfo:n}=r,c=n!=null&&!!i.transposedVariableName;if(this._slices&&!c&&i.sliceId==null)return null;const l=c?0:r.maximumPyramidLevel-s+this._levelOffset,o=`${this.url}/tile/${l}/${e}/${t}`,u=this._slices?c?{variable:i.transposedVariableName}:{sliceId:i.sliceId||0}:null;let p,f;if(r.isBsqTile){const P=((J=i.bandIds)!=null&&J.length?i.bandIds:[0,1,2]).map(H=>this.request(o,{query:{...u,bandId:H},responseType:"array-buffer",signal:i.signal})),$=await Promise.all(P),E=$.map(H=>H.data.byteLength).reduce((H,De)=>H+De),z=new Uint8Array(E);f=[];let ue=0;for(const{data:H}of $)f.push(ue),z.set(new Uint8Array(H),ue),ue+=H.byteLength;p=z.buffer}else p=(await this.request(o,{query:u,responseType:"array-buffer",signal:i.signal})).data;if(!p)return null;const h=c?n.tileSize:r.tileInfo.size,w=await this.decodePixelBlock(p,{width:h[0],height:h[1],planes:f==null?void 0:f.length,offsets:f,pixelType:null,isPoint:this.tileType==="Elevation",returnInterleaved:c,noDataValue:this.rasterInfo.noDataValue});if(w==null)return null;const d=r.blockBoundary[s];if(r.compression!=="jpg"||t>d.minCol&&t<d.maxCol&&e>d.minRow&&e<d.maxRow)return w;const{origin:m,blockWidth:g,blockHeight:y}=r,{x:S,y:v}=this.getPyramidPixelSize(s),x=Math.round((a.xmin-m.x)/S)%g,T=Math.round((a.xmax-m.x)/S)%g||g,I=Math.round((m.y-a.ymax)/v)%y,O=Math.round((m.y-a.ymin)/v)%y||y,b=t===d.minCol?x:0,k=e===d.minRow?I:0,_=t===d.maxCol?T:g,M=e===d.maxRow?O:y;return Ft(w,{x:b,y:k},{width:_-b,height:M-k}),w}getSliceIndex(s){if(!this._slices||s==null||s.length===0)return null;const e=s;for(let t=0;t<this._slices.length;t++){const i=this._slices[t].multidimensionalDefinition;if(i.length===e.length&&!i.some(r=>{const a=e.find(n=>r.variableName===n.variableName&&n.dimensionName===r.dimensionName);return a?(Array.isArray(r.values[0])?`${r.values[0][0]}-${r.values[0][1]}`:r.values[0])!==(Array.isArray(a.values[0])?`${a.values[0][0]}-${a.values[0][1]}`:a.values[0]):!0}))return t}return null}async fetchVariableStatisticsHistograms(s,e){var a,n,c;const t=this.request(this.url+"/statistics",{query:{variable:s,f:"json"},signal:e}).then(l=>{var o;return(o=l.data)==null?void 0:o.statistics}),i=this.request(this.url+"/histograms",{query:{variable:s,f:"json"},signal:e}).then(l=>{var o;return(o=l.data)==null?void 0:o.histograms}),r=await Promise.all([t,i]);return r[0]&&r[0].forEach(l=>{l.avg=l.mean,l.stddev=l.standardDeviation}),(c=(n=(a=r[1])==null?void 0:a[0])==null?void 0:n.counts)!=null&&c.length||(r[1]=null),{statistics:r[0]||null,histograms:r[1]||null}}async computeBestPyramidLevelForLocation(s,e={}){if(!this._tilemapCache)return 0;let t=this.identifyPixelLocation(s,0,e.datumTransformation);if(t===null)return null;let i=0;const{maximumPyramidLevel:r}=this.rasterInfo.storageInfo;let a=r-i+this._levelOffset;const n=t.srcLocation;for(;a>=0;){try{if(await this._tilemapCache.fetchAvailability(a,t.row,t.col,e)==="available")break}catch{}if(a--,i++,t=this.identifyPixelLocation(n,i,e.datumTransformation),t===null)return null}return a===-1||t==null?null:i}async _open(s){var I,O;const e=s==null?void 0:s.signal,t=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:e});t.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const i=t.data;if(this.sourceJSON=i,!i)throw new F("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!i.tileInfo)throw new F("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();const r=["jpg","jpeg","png","png8","png24","png32","mixed"];this.tileType=i.cacheType,this.tileType==null&&(r.includes(i.tileInfo.format.toLowerCase())?this.tileType="Map":i.tileInfo.format.toLowerCase()==="lerc"?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=((I=i.name)==null?void 0:I.slice(i.name.indexOf("/")+1))??"";const a=await this._fetchRasterInfo({signal:e});if(a==null)throw new F("image-server-raster:open","cannot initialize image service");lt(a,i);const n=this.tileType==="Map"?Qt(i.tileInfo,i):ne.fromJSON(i.tileInfo);He(n);const[c,l]=this._computeMinMaxLOD(a,n),{extent:o,pixelSize:u}=a,p=.5/a.width*u.x,f=Math.max(u.x,u.y),{lods:h}=n;(this.tileType!=="Map"&&i.maxScale!==0||Math.abs(u.x-u.y)>p||!h.some(b=>Math.abs(b.resolution-f)<p))&&(u.x=u.y=c.resolution,a.width=Math.ceil((o.xmax-o.xmin)/u.x-.1),a.height=Math.ceil((o.ymax-o.ymin)/u.y-.1));const w=c.level-l.level,[d,m]=n.size,g=[],y=[];h.forEach((b,k)=>{b.level>=l.level&&b.level<=c.level&&g.push({x:b.resolution,y:b.resolution}),k<h.length-1&&y.push(Math.round(10*b.resolution/h[k+1].resolution)/10)}),g.sort((b,k)=>b.x-k.x);const S=this.computeBlockBoundary(o,d,m,n.origin,g,w),v=g.length>1?g.slice(1):null;let x;i.transposeInfo&&(x={tileSize:[i.transposeInfo.rows,i.transposeInfo.cols],packetSize:((O=a.keyProperties)==null?void 0:O._yxs.PacketSize)??0});const T=y.length<=1||y.length>=3&&y.slice(0,-1).every(b=>b===y[0])?y[0]??2:Math.round(10/(l.resolution/c.resolution)**(-1/w))/10;if(a.storageInfo=new xe({blockWidth:n.size[0],blockHeight:n.size[1],pyramidBlockWidth:n.size[0],pyramidBlockHeight:n.size[1],pyramidResolutions:v,pyramidScalingFactor:T,compression:n.format,origin:n.origin,firstPyramidLevel:1,maximumPyramidLevel:w,tileInfo:n,isBsqTile:!!i.bsq,transposeInfo:x,blockBoundary:S}),es(a),this._set("rasterInfo",a),i.capabilities.toLowerCase().includes("tilemap")){const b={tileInfo:a.storageInfo.tileInfo,parsedUrl:je(this.url),url:this.url,tileServers:[]};this._tilemapCache=new zt({layer:b})}}async _fetchRasterInfo(s){const e=this.sourceJSON;if(this.tileType==="Map"){const n=e.fullExtent||e.extent,c=Math.ceil((n.xmax-n.xmin)/e.pixelSizeX-.1),l=Math.ceil((n.ymax-n.ymin)/e.pixelSizeY-.1),o=A.fromJSON(e.spatialReference||n.spatialReference),u=new V({x:e.pixelSizeX,y:e.pixelSizeY,spatialReference:o});return new le({width:c,height:l,bandCount:3,extent:W.fromJSON(n),spatialReference:o,pixelSize:u,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:t}=s,i=ct(this.url,this.sourceJSON,{signal:t,query:this.ioConfig.customFetchParameters}),r=e.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:t}).then(n=>{var c;return(c=n.data)==null?void 0:c.slices}).catch(()=>null):null,a=await Promise.all([i,r]);return this._slices=a[1],a[0]}_fixScaleInServiceInfo(){const{sourceJSON:s}=this;s.minScale&&s.minScale<0&&(s.minScale=0),s.maxScale&&s.maxScale<0&&(s.maxScale=0)}_computeMinMaxLOD(s,e){const{pixelSize:t}=s,i=.5/s.width*t.x,{lods:r}=e,a=e.lodAt(Math.max.apply(null,r.map(f=>f.level))),n=e.lodAt(Math.min.apply(null,r.map(f=>f.level))),{tileType:c}=this;if(c==="Map")return this._levelOffset=r[0].level,[a,n];if(c==="Raster")return[r.find(f=>f.resolution===t.x)??a,n];const{minScale:l,maxScale:o}=this.sourceJSON;let u=a;o>0&&(u=r.find(f=>Math.abs(f.scale-o)<i),u||(u=r.filter(f=>f.scale>o).sort((f,h)=>f.scale>h.scale?1:-1)[0]??a));let p=n;return l>0&&(p=r.find(f=>Math.abs(f.scale-l)<i)??n,this._levelOffset=p.level-n.level),[u,p]}};function Qt(s,e){if(!s)return null;const{minScale:t,maxScale:i,minLOD:r,maxLOD:a}=e;if(r!=null&&a!=null)return ne.fromJSON({...s,lods:s.lods.filter(({level:n})=>n!=null&&n>=r&&n<=a)});if(t!==0&&i!==0){const n=o=>Math.round(1e4*o)/1e4,c=t?n(t):1/0,l=i?n(i):-1/0;return ne.fromJSON({...s,lods:s.lods.filter(o=>{const u=n(o.scale);return u<=c&&u>=l})})}return ne.fromJSON(s)}function es(s){const{extent:e,spatialReference:t}=s;e.xmin>-1&&e.xmax>181&&(t!=null&&t.wkid)&&t.isGeographic&&(s.nativeExtent=s.extent,s.transform=new Jt,s.extent=s.transform.forwardTransform(e))}R([C({type:String,json:{write:!0}})],ee.prototype,"datasetFormat",void 0),R([C()],ee.prototype,"tileType",void 0),ee=R([Y("esri.layers.support.rasterDatasets.ImageServerRaster")],ee);const ts=ee,B=new Map;B.set("Int8","s8"),B.set("UInt8","u8"),B.set("Int16","s16"),B.set("UInt16","u16"),B.set("Int32","s32"),B.set("UInt32","u32"),B.set("Float32","f32"),B.set("Float64","f32"),B.set("Double64","f32");const G=new Map;G.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),G.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),G.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),G.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let K=class extends Z{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async fetchRawTile(s,e,t,i={}){const{blockWidth:r,blockHeight:a,blockBoundary:n}=this.rasterInfo.storageInfo,c=n[s];if(!c||c.maxRow<e||c.maxCol<t||c.minRow>e||c.minCol>t)return null;const{bandCount:l,pixelType:o}=this.rasterInfo,{ranges:u,actualTileWidth:p,actualTileHeight:f}=this._getTileLocation(s,e,t);if(!u||u.length===0)return null;if(u[0].from===0&&u[0].to===0){const _=new Uint8Array(r*a);return new ae({width:r,height:a,pixels:void 0,mask:_,validPixelCount:0})}const{bandIds:h}=this.ioConfig,w=this._getBandSegmentCount(),d=[];let m=0;for(m=0;m<w;m++)h&&!h.includes(m)||d.push(this.request(this._files.data,{range:{from:u[m].from,to:u[m].to},responseType:"array-buffer",signal:i.signal}));const g=await Promise.all(d),y=g.map(_=>_.data.byteLength).reduce((_,M)=>_+M),S=new Uint8Array(y),v=[];let x=0;for(m=0;m<w;m++)v.push(x),S.set(new Uint8Array(g[m].data),x),x+=g[m].data.byteLength;const T=G.get(this.rasterInfo.storageInfo.compression).decoderFormat,I=await this.decodePixelBlock(S.buffer,{width:r,height:a,format:T,planes:(h==null?void 0:h.length)||l,offsets:v,pixelType:o});if(I==null)return null;let{noDataValue:O}=this.rasterInfo;if(O!=null&&T!=="lerc"&&!I.mask&&(O=O[0],O!=null)){const _=I.width*I.height,M=new Uint8Array(_);if(Math.abs(O)>1e24)for(m=0;m<_;m++)Math.abs((I.pixels[0][m]-O)/O)>1e-6&&(M[m]=1);else for(m=0;m<_;m++)I.pixels[0][m]!==O&&(M[m]=1);I.mask=M}let b=0,k=0;if(p!==r||f!==a){let _=I.mask;if(_)for(m=0;m<a;m++)if(k=m*r,m<f)for(b=p;b<r;b++)_[k+b]=0;else for(b=0;b<r;b++)_[k+b]=0;else for(_=new Uint8Array(r*a),I.mask=_,m=0;m<f;m++)for(k=m*r,b=0;b<p;b++)_[k+b]=1}return I}async _open(s){this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const e=s?s.signal:null,t=await this.request(this.url,{responseType:"xml",signal:e}),{rasterInfo:i,files:r}=this._parseHeader(t.data),{skipMapInfo:a,skipExtensions:n=[]}=this.ioConfig;if(!n.includes("aux.xml")&&!a){const g=await this._fetchAuxiliaryData(s);g!=null&&(i.statistics=g.statistics??i.statistics,i.histograms=g.histograms,g.histograms&&i.statistics==null&&(i.statistics=we(g.histograms)))}a&&this.updateImageSpaceRasterInfo(i),this._set("rasterInfo",i),this._files=r;const c=await this.request(r.index,{responseType:"array-buffer",signal:e});this._storageIndex=ss(c.data);const{blockWidth:l,blockHeight:o}=this.rasterInfo.storageInfo,u=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:p,height:f}=this.rasterInfo,h=[],w=this._getBandSegmentCount();let d=0,m=-1;for(;d<this._storageIndex.length;){m++;const g=Math.ceil(p/l/u**m)-1,y=Math.ceil(f/o/u**m)-1;d+=(g+1)*(y+1)*w*4,h.push({maxRow:y,maxCol:g,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=h,m>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=m),this.updateTileInfo()}_getBandSegmentCount(){return G.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(s,e,t){const{blockWidth:i,blockHeight:r,pyramidScalingFactor:a}=this.rasterInfo.storageInfo,{width:n,height:c}=this.rasterInfo,l=this._getBandSegmentCount();let o,u,p,f=0,h=0;for(p=0;p<s;p++)h=a**p,o=Math.ceil(n/i/h),u=Math.ceil(c/r/h),f+=o*u;h=a**s,o=Math.ceil(n/i/h),u=Math.ceil(c/r/h),f+=e*o+t,f*=4*l;const w=this._storageIndex.subarray(f,f+4*l);let d=0,m=0;const g=[];for(let y=0;y<l;y++)d=w[4*y]*2**32+w[4*y+1],m=d+w[4*y+2]*2**32+w[4*y+3],g.push({from:d,to:m});return{ranges:g,actualTileWidth:t<o-1?i:Math.ceil(n/h)-i*(o-1),actualTileHeight:e<u-1?r:Math.ceil(c/h)-r*(u-1)}}_parseHeader(s){const e=L(s,"MRF_META/Raster");if(!e)throw new F("mrf:open","not a valid MRF format");const t=L(e,"Size"),i=parseInt(t.getAttribute("x"),10),r=parseInt(t.getAttribute("y"),10),a=parseInt(t.getAttribute("c"),10),n=(U(e,"Compression")||"none").toLowerCase();if(!G.has(n))throw new F("mrf:open","currently does not support compression "+n);const c=U(e,"DataType")||"UInt8",l=B.get(c);if(l==null)throw new F("mrf:open","currently does not support pixel type "+c);const o=L(e,"PageSize"),u=parseInt(o.getAttribute("x"),10),p=parseInt(o.getAttribute("y"),10),f=L(e,"DataValues");let h,w;if(f&&(w=f.getAttribute("NoData"),w!=null&&(h=w.trim().split(" ").map(_=>parseFloat(_)))),L(s,"MRF_META/CachedSource"))throw new F("mrf:open","currently does not support MRF referencing other data files");const d=L(s,"MRF_META/GeoTags"),m=L(d,"BoundingBox");let g,y=!1;if(m!=null){const _=parseFloat(m.getAttribute("minx")),M=parseFloat(m.getAttribute("miny")),J=parseFloat(m.getAttribute("maxx")),P=parseFloat(m.getAttribute("maxy")),$=U(d,"Projection")||"";let E=A.WGS84;if($!=="LOCAL_CS[]")if($.toLowerCase().startsWith("epsg:")){const z=Number($.slice(5));isNaN(z)||z===0||(E=new A({wkid:z}))}else E=ce($)??A.WGS84;else y=!0,E=new A({wkid:3857});g=new W(_,M,J,P),g.spatialReference=E}else y=!0,g=new W({xmin:-.5,ymin:.5-r,xmax:i-.5,ymax:.5,spatialReference:new A({wkid:3857})});const S=L(s,"MRF_META/Rsets"),v=parseInt((S==null?void 0:S.getAttribute("scale"))||"2",10),x=g.spatialReference,T=new xe({origin:new V({x:g.xmin,y:g.ymax,spatialReference:x}),blockWidth:u,blockHeight:p,pyramidBlockWidth:u,pyramidBlockHeight:p,compression:n,pyramidScalingFactor:v}),I=new V({x:g.width/i,y:g.height/r,spatialReference:x}),O=new le({width:i,height:r,extent:g,isPseudoSpatialReference:y,spatialReference:x,bandCount:a,pixelType:l,pixelSize:I,noDataValue:h,storageInfo:T}),b=U(s,"datafile"),k=U(s,"IndexFile");return{rasterInfo:O,files:{mrf:this.url,index:k||this.url.replace(".mrf",".idx"),data:b||this.url.replace(".mrf",G.get(n).blobExtension)}}}async _fetchAuxiliaryData(s){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:s==null?void 0:s.signal});return ve(e)}catch{return null}}};function ss(s){if(s.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let e,t,i,r,a,n;if(Pt){for(t=new Uint8Array(s),r=new ArrayBuffer(s.byteLength),i=new Uint8Array(r),a=0;a<s.byteLength/4;a++)for(n=0;n<4;n++)i[4*a+n]=t[4*a+3-n];e=new Uint32Array(r)}else e=new Uint32Array(s);return e}R([C()],K.prototype,"_files",void 0),R([C()],K.prototype,"_storageIndex",void 0),R([C({type:String,json:{write:!0}})],K.prototype,"datasetFormat",void 0),K=R([Y("esri.layers.support.rasterDatasets.MRFRaster")],K);const is=K;function rs(s){const e=s.fields,t=s.records,i=e.some(o=>o.name.toLowerCase()==="oid")?"OBJECTID":"OID",r=[{name:i,type:"esriFieldTypeOID",alias:"OID"}].concat(e.map(o=>({name:o.name,type:"esriFieldType"+o.typeName,alias:o.name}))),a=r.map(o=>o.name),n=[];let c=0,l=0;return t.forEach(o=>{const u={};for(u[i]=c++,l=1;l<a.length;l++)u[a[l]]=o[l-1];n.push({attributes:u})}),{displayFieldName:"",fields:r,features:n}}class as{static get supportedVersions(){return[5]}static parse(e){const t=new DataView(e),i=3&t.getUint8(0);if(i!==3)return{header:{version:i},recordSet:null};const r=t.getUint32(4,!0),a=t.getUint16(8,!0),n=t.getUint16(10,!0),c={version:i,recordCount:r,headerByteCount:a,recordByteCount:n};let l=32;const o=[],u=[];let p;if(i===3){for(;t.getUint8(l)!==13;)p=String.fromCharCode(t.getUint8(l+11)).trim(),o.push({name:Re(new Uint8Array(e,l,11)),type:p,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(p)],length:t.getUint8(l+16)}),l+=32;if(l+=1,o.length>0)for(;u.length<r&&e.byteLength-l>n;){const f=[];t.getUint8(l)===32?(l+=1,o.forEach(h=>{if(h.type==="C")f.push(Re(new Uint8Array(e,l,h.length)).trim());else if(h.type==="N")f.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(e,l,h.length)).trim(),10));else if(h.type==="F")f.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(e,l,h.length)).trim()));else if(h.type==="D"){const w=String.fromCharCode.apply(null,new Uint8Array(e,l,h.length)).trim();f.push(new Date(parseInt(w.slice(0,4),10),parseInt(w.slice(4,6),10)-1,parseInt(w.slice(6,8),10)))}l+=h.length}),u.push(f)):l+=n}}return{header:c,fields:o,records:u,recordSet:rs({fields:o,records:u})}}}const ye=(s,e)=>{var t;return(t=s.get(e))==null?void 0:t.values},te=(s,e)=>{var t,i;return(i=(t=s.get(e))==null?void 0:t.values)==null?void 0:i[0]};let j=class extends Z{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this._chunkSize=10485760,this.datasetFormat="TIFF"}async fetchRawTile(e,t,i,r={}){var n;if(!((n=this._headerInfo)!=null&&n.isSupported)||this.isBlockOutside(e,t,i))return null;const a=await this._fetchRawTiffTile(e,t,i,!1,r);if(a!=null&&this._headerInfo.hasMaskBand){const c=await this._fetchRawTiffTile(e,t,i,!0,r);c!=null&&c.pixels[0]instanceof Uint8Array&&(a.mask=c.pixels[0])}return a}async _open(e){var g,y,S,v;const t=e?e.signal:null,{data:i}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:t});if(!i)throw new F("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:r,firstIFDPos:a,isBigTiff:n}=Nt(i),c=[],l={fileChunk:i,posIFD:a,fileOffset:0};await this._readIFDs(c,l,r,n?8:4,t);const{imageInfo:o,rasterInfo:u}=ns(c),p=$t(c),f=Et(c);if(this._headerInfo={littleEndian:r,isBigTiff:n,ifds:c,pyramidIFDs:p,maskIFDs:f,...o},this._set("rasterInfo",u),!o.isSupported)throw new F("tiffraster:open","this tiff is not supported: "+o.message);if(!o.tileWidth)throw new F("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");u.isPseudoSpatialReference&&ge.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const h=(y=(g=c[0].get("PREDICTOR"))==null?void 0:g.values)==null?void 0:y[0];if(((v=(S=c[0].get("SAMPLEFORMAT"))==null?void 0:S.values)==null?void 0:v[0])===3&&h===2)throw new F("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");const{skipMapInfo:d,skipExtensions:m=[]}=this.ioConfig;if(!m.includes("aux.xml")&&!d){const x=await this._fetchAuxiliaryMetaData(e);x!=null&&os(x,u)}m.includes("vat.dbf")||u.bandCount!==1||u.pixelType!=="u8"||d||(u.attributeTable=await this._fetchAuxiliaryTable(e),u.attributeTable!=null&&(u.keyProperties.DataType="thematic")),d&&this.updateImageSpaceRasterInfo(u),this.updateTileInfo()}async _validateOrFetchHeaderBuffer(e,t){let{fileChunk:i,fileOffset:r,posIFD:a}=e;return(a+8>=i.byteLength||a<0)&&(r=a+r,i=(await this.request(this.url,{range:{from:r,to:r+this._bufferSize},responseType:"array-buffer",signal:t})).data,a=0),{fileChunk:i,fileOffset:r,posIFD:a}}async _readIFDs(e,t,i,r=4,a){if(!t.posIFD)return null;t=await this._validateOrFetchHeaderBuffer(t,a);const n=await this._readIFD(t,i,_e,r,a);if(!(n!=null&&n.ifd))throw new F("tiffraster:open","cannot parse tiff header. failed to open url "+this.url);if(e.push(n.ifd),!n.nextIFD)return null;t.posIFD=n.nextIFD-t.fileOffset,await this._readIFDs(e,t,i,r,a)}async _readIFD(e,t,i=_e,r=4,a){var u,p;let{fileChunk:n,posIFD:c,fileOffset:l}=e;if(!e.fileChunk)return null;const o=Dt(n,t,c,l,i,r);if(o.success){const f=[];if((u=o.ifd)==null||u.forEach(h=>{h.values||f.push(h)}),f.length>0&&await this._fillOffsets(f,t,o.nextIFD,a),(p=o.ifd)==null?void 0:p.has("GEOKEYDIRECTORY")){const h=o.ifd.get("GEOKEYDIRECTORY"),w=h==null?void 0:h.values;if(w&&w.length>4){const d=w[0]+"."+w[1]+"."+w[2];c=h.valueOffset+6-l;const m=await this._validateOrFetchHeaderBuffer({fileChunk:n,posIFD:c,fileOffset:l},a),g=await this._readIFD(m,t,At,2,a);h.data=g==null?void 0:g.ifd,h.data&&h.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[d]})}}return o}return o.requiredBufferSize?(n=(await this.request(this.url,{range:{from:l,to:l+c+o.requiredBufferSize+8},responseType:"array-buffer",signal:a})).data,n.byteLength<c+o.requiredBufferSize?null:(e.fileChunk=n,e.fileOffset=l,this._readIFD(e,t,i,r,a))):null}async _fillOffsets(e,t,i,r){const a=e.filter(p=>p.offlineOffsetSize!=null);if(a.length===0)return;const n=a.map(p=>p.offlineOffsetSize),c=Math.min.apply(null,n.map(p=>p[0])),l=Math.max.apply(null,n.map(p=>p[0]+p[1]));let o=n.length===1||l-c<=this._bufferSize;if(!o&&n.length>1&&(n.sort((p,f)=>p[0]-f[0]),o=n.reduce((p,f)=>p===f[0]?f[0]+f[1]:0,n[0][0])===l),o){const p=await this._fetchOffsets(c,Math.max(l,c+this._bufferSize),r);return void a.forEach(f=>Oe(p,t,f,c))}const u=a.map(async p=>{const f=p.offlineOffsetSize,h=await this._fetchOffsets(f[0],f[1]+f[0],r);Oe(h,t,p,f[0])});await Promise.all(u)}async _fetchOffsets(e,t,i){const r=[],a=this._chunkSize,n=Math.ceil((t-e)/a);let c=e;for(let u=0;u<n;u++)r.push(this.request(this.url,{range:{from:c,to:u===n-1?t:c+a-1},responseType:"array-buffer",signal:i})),c+=a;const l=await Promise.all(r);if(n===1)return l[0].data;const o=new Uint8Array(t-e+1);for(let u=0;u<n;u++)o.set(new Uint8Array(l[u].data),u*a);return o.buffer}async _fetchRawTiffTile(e,t,i,r,a={}){const n=this._getTileLocation(e,t,i,r);if(!n)return null;const{ranges:c,actualTileWidth:l,actualTileHeight:o,ifd:u}=n,p=c.map(I=>this.request(this.url,{range:I,responseType:"array-buffer",signal:a.signal})),f=await Promise.all(p),h=f.map(I=>I.data.byteLength).reduce((I,O)=>I+O),w=f.length===1?f[0].data:new ArrayBuffer(h),d=[0],m=[0];if(f.length>1){const I=new Uint8Array(w);for(let O=0,b=0;O<f.length;O++){const k=f[O].data;I.set(new Uint8Array(k),b),d[O]=b,b+=k.byteLength,m[O]=k.byteLength}}const{blockWidth:g,blockHeight:y}=this.getBlockWidthHeight(e),S=await this.decodePixelBlock(w,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:u,offsets:d,sizes:m},width:g,height:y,planes:null,pixelType:null});if(S==null)return null;let v,x,T;if(l!==g||o!==y){let I=S.mask;if(I)for(v=0;v<y;v++)if(T=v*g,v<o)for(x=l;x<g;x++)I[T+x]=0;else for(x=0;x<g;x++)I[T+x]=0;else for(I=new Uint8Array(g*y),S.mask=I,v=0;v<o;v++)for(T=v*g,x=0;x<l;x++)I[T+x]=1}return S}_getTileLocation(e,t,i,r=!1){const{firstPyramidLevel:a,blockBoundary:n}=this.rasterInfo.storageInfo,c=e===0?0:e-(a-1),{_headerInfo:l}=this;if(!l)return null;const o=r?l.maskIFDs[c]:c===0?l==null?void 0:l.ifds[0]:l==null?void 0:l.pyramidIFDs[c-1];if(!o)return null;const u=Bt(o,l),p=ye(o,"TILEOFFSETS");if(p===void 0)return null;const f=ye(o,"TILEBYTECOUNTS"),{minRow:h,minCol:w,maxRow:d,maxCol:m}=n[c];if(t>d||i>m||t<h||i<w)return null;const g=te(o,"IMAGEWIDTH"),y=te(o,"IMAGELENGTH"),S=te(o,"TILEWIDTH"),v=te(o,"TILELENGTH"),x=[];if(u){const{bandCount:T}=this.rasterInfo;for(let I=0;I<T;I++){const O=I*(d+1)*(m+1)+t*(m+1)+i;x[I]={from:p[O],to:p[O]+f[O]-1}}}else{const T=t*(m+1)+i;x.push({from:p[T],to:p[T]+f[T]-1})}for(let T=0;T<x.length;T++)if(x[T].from==null||!x[T].to||x[T].to<0)return null;return{ranges:x,ifd:o,actualTileWidth:i===m&&g%S||S,actualTileHeight:t===d&&y%v||v}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e==null?void 0:e.signal});return ve(t)}catch{return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:e==null?void 0:e.signal}),i=as.parse(t);return i!=null&&i.recordSet?Ne.fromJSON(i.recordSet):null}catch{return null}}};function ns(s){var J,P;const e=Lt(s),{width:t,height:i,tileWidth:r,tileHeight:a,planes:n,pixelType:c,compression:l,firstPyramidLevel:o,maximumPyramidLevel:u,pyramidBlockWidth:p,pyramidBlockHeight:f,pyramidResolutions:h,tileBoundary:w,affine:d,metadata:m}=e,g=((J=e.extent.spatialReference)==null?void 0:J.wkt)||((P=e.extent.spatialReference)==null?void 0:P.wkid);let y=ce(g),S=!!e.isPseudoGeographic;y==null&&(S=!0,y=new A({wkid:3857}));const v=new W({...e.extent,spatialReference:y}),x=new V(v?{x:v.xmin,y:v.ymax,spatialReference:y}:{x:0,y:0}),T=new xe({blockWidth:r,blockHeight:a,pyramidBlockWidth:p,pyramidBlockHeight:f,compression:l,origin:x,firstPyramidLevel:o,maximumPyramidLevel:u,pyramidResolutions:h,blockBoundary:w}),I=new V({x:(v.xmax-v.xmin)/t,y:(v.ymax-v.ymin)/i,spatialReference:y}),O=m?{BandProperties:m.bandProperties,DataType:m.dataType}:{};let b=null;const k=te(s[0],"PHOTOMETRICINTERPRETATION"),_=ye(s[0],"COLORMAP");if(k<=3&&(_==null?void 0:_.length)>3&&_.length%3==0){b=[];const $=_.length/3;for(let E=0;E<$;E++)b.push([E,_[E]>>>8,_[E+$]>>>8,_[E+2*$]>>>8])}const M=new le({width:t,height:i,bandCount:n,pixelType:c,pixelSize:I,storageInfo:T,spatialReference:y,isPseudoSpatialReference:S,keyProperties:O,extent:v,colormap:b,statistics:m?m.statistics:null});if(d!=null&&d.length&&(M.nativeExtent=new W({xmin:-.5,ymin:.5-i,xmax:t-.5,ymax:.5,spatialReference:y}),M.transform=new Ie({polynomialOrder:1,forwardCoefficients:[d[2]+d[0]/2,d[5]-d[3]/2,d[0],d[3],-d[1],-d[4]]}),M.extent=M.transform.forwardTransform(M.nativeExtent),M.pixelSize=new V({x:(v.xmax-v.xmin)/t,y:(v.ymax-v.ymin)/i,spatialReference:y}),T.origin.x=-.5,T.origin.y=.5),h){const{x:$,y:E}=M.pixelSize;h.forEach(z=>{z.x*=$,z.y*=E})}return{imageInfo:e,rasterInfo:M}}function os(s,e){if(e.statistics=s.statistics??e.statistics,e.histograms=s.histograms,s.histograms&&e.statistics==null&&(e.statistics=we(s.histograms)),s.transform&&e.transform==null){e.transform=s.transform,e.nativeExtent=e.extent;const t=e.transform.forwardTransform(e.nativeExtent);e.pixelSize=new V({x:(t.xmax-t.xmin)/e.width,y:(t.ymax-t.ymin)/e.height,spatialReference:e.spatialReference}),e.extent=t}e.isPseudoSpatialReference&&s.spatialReference&&(e.spatialReference=s.spatialReference,e.extent.spatialReference=e.nativeExtent.spatialReference=e.storageInfo.origin.spatialReference=e.spatialReference)}R([C()],j.prototype,"_files",void 0),R([C()],j.prototype,"_headerInfo",void 0),R([C()],j.prototype,"_bufferSize",void 0),R([C()],j.prototype,"_chunkSize",void 0),R([C({type:String,json:{write:!0}})],j.prototype,"datasetFormat",void 0),j=R([Y("esri.layers.support.rasterDatasets.TIFFRaster")],j);const ls=j,D=new Map;D.set("MRF",{desc:"Meta Raster Format",constructor:is}),D.set("TIFF",{desc:"GeoTIFF",constructor:ls}),D.set("RasterTileServer",{desc:"Raster Tile Server",constructor:ts}),D.set("JPG",{desc:"JPG Raster Format",constructor:re}),D.set("PNG",{desc:"PNG Raster Format",constructor:re}),D.set("GIF",{desc:"GIF Raster Format",constructor:re}),D.set("BMP",{desc:"BMP Raster Format",constructor:re}),D.set("CovJSON",{desc:"COVJSON Raster Format",constructor:Xt}),D.set("MEMORY",{desc:"In Memory Raster Format",constructor:be});class de{static get supportedFormats(){const e=new Set;return D.forEach((t,i)=>e.add(i)),e}static async open(e){var p;const{url:t,ioConfig:i,source:r,sourceJSON:a}=e;let n=e.datasetFormat??(i==null?void 0:i.datasetFormat);n==null&&(t.includes(".")?n=t.slice(t.lastIndexOf(".")+1).toUpperCase():((p=r==null?void 0:r.type)==null?void 0:p.toLowerCase())==="coverage"?n="CovJSON":r!=null&&r.extent&&r.pixelblocks&&(n="MEMORY")),n==="OVR"||n==="TIF"?n="TIFF":n==="JPG"||n==="JPEG"||n==="JFIF"?n="JPG":n==="COVJSON"&&(n="CovJSON"),t.toLowerCase().includes("/imageserver")&&!t.toLowerCase().includes("/wcsserver")&&(n="RasterTileServer");const c={url:t,source:r,sourceJSON:a,datasetFormat:n,ioConfig:i??{bandIds:null,sampling:null}};if(Object.keys(c).forEach(f=>{c[f]==null&&delete c[f]}),n){if(!this.supportedFormats.has(n))throw new F("rasterfactory:open","not a supported format "+n);if(n==="CRF")throw new F("rasterfactory:open",`cannot open raster: ${t}`);const f=new(D.get(n)).constructor(c);return await f.open({signal:e.signal}),f}const l=Array.from(D.keys()).filter(f=>f!=="CovJSON"&&f!=="Memory");let o=0;const u=()=>{if(n=l[o++],!n||n==="CRF")return null;const f=new(D.get(n)).constructor(c);return f.open({signal:e.signal}).then(()=>f).catch(()=>u())};return u()}static register(e,t,i){D.has(e.toUpperCase())||D.set(e.toUpperCase(),{desc:t,constructor:i})}}let N=class extends et(pt(rt(nt(ut(tt(st(ot(ht(Qe(ft(Ke(Ge.ClonableMixin(Ze))))))))))))){constructor(...s){super(...s),this._primaryRasters=[],this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this.source=void 0,this._debouncedSaveOperations=We(async(e,t,i)=>{const{save:r,saveAs:a}=await Ae(()=>import("./imageryUtils-v-XKdPbN.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13]));switch(e){case ie.SAVE:return r(this,t);case ie.SAVE_AS:return a(this,i,t)}})}normalizeCtorArgs(s,e){return typeof s=="string"?{url:s,...e}:s}load(s){const e=s!=null?s.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},s).catch(qe).then(()=>this._openRaster(e))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){var a,n;const s=[gt("Pixel Value"),yt("Raw Pixel Value")],e=((a=this.raster)==null?void 0:a.rasterInfo)??this.serviceRasterInfo,t=e==null?void 0:e.attributeTable;if(t){const c=wt(t);s.push(...c)}const i=e==null?void 0:e.dataType,r=e==null?void 0:e.multidimensionalInfo;if((i==="vector-magdir"||i==="vector-uv")&&r!=null){const c=(n=r.variables[0].unit)==null?void 0:n.trim(),l=xt(c),o=It();s.push(l,o)}if(r){const c=bt(r);s.push(...c)}return s}createPopupTemplate(s){const{rasterFields:e}=this,t=(s==null?void 0:s.visibleFieldNames)??new Set(e.map(({name:a})=>a).filter(a=>a!==vt.rawServicePixelValue)),i=jt({fields:e,title:this.title},{...s,visibleFieldNames:t}),{rasterInfo:r}=this.raster;return i!=null&&i.fieldInfos&&r&&St(i.fieldInfos,r),i}async generateRasterInfo(s,e){var t;if(s=Ve(Me,s),await this.load(),!s||((t=s.functionName)==null?void 0:t.toLowerCase())==="none")return this.serviceRasterInfo;try{const{rasterInfo:i}=await this._openFunctionRaster(s,e);return i}catch(i){throw i instanceof F?i:new F("imagery-tile-layer","the given raster function is not supported")}}async save(s){return this._debouncedSaveOperations(ie.SAVE,s)}async saveAs(s,e){return this._debouncedSaveOperations(ie.SAVE_AS,e,s)}write(s,e){const t=this._primaryRasters[0]??this.raster;if(this.loaded?t.datasetFormat==="RasterTileServer"&&(t.tileType==="Raster"||t.tileType==="Map"):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(s,e);if(e!=null&&e.messages){const i=`${e.origin}/${e.layerContainerType||"operational-layers"}`;e.messages.push(new F("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${i}'`,{layer:this}))}return null}async _openRaster(s){var i;let e=!1;if(this.raster)await this._openFromRaster(this.raster,s),e=Tt(this.raster),!e&&this.rasterFunction&&(this._primaryRasters=[this.raster],await this._initializeWithFunctionRaster(this.rasterFunction));else{const{url:r,rasterFunction:a,source:n}=this;if(!r&&!n)throw new F("imagery-tile-layer:open","missing url or source parameter");n?await this._openFromSource(n,s):a?await this._openFromUrlWithRasterFunction(r,a,s):await this._openFromUrl(r,s)}const t=this.raster.rasterInfo;if(!t)throw new F("imagery-tile-layer:load","cannot load resources on "+this.url);if(this._set("serviceRasterInfo",e?t:this._primaryRasters[0].rasterInfo),this._set("spatialReference",t.spatialReference),this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,this.sourceJSON!=null){const r=this.raster.tileType==="Map"&&this.sourceJSON.minLOD!=null&&this.sourceJSON.maxLOD!=null?this.sourceJSON:{...this.sourceJSON,minScale:0,maxScale:0};this.read(r,{origin:"service"})}else this.read({tileInfo:(i=this.serviceRasterInfo)==null?void 0:i.storageInfo.tileInfo.toJSON()},{origin:"service"});this.title||(this.title=this.raster.datasetName),this.raster.tileType==="Map"&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles(Ye(()=>this.customParameters,r=>{this.raster&&(this.raster.ioConfig.customFetchParameters=r)}))}async _openFromRaster(s,e){s.rasterInfo||await s.open({signal:e}),this._primaryRasters=Rt(s),this.url||(this.url=this._primaryRasters[0].url)}async _openFromUrlWithRasterFunction(s,e,t){const i=[s];e&&Ut(e.toJSON(),i);const r=await Promise.all(i.map(n=>de.open({url:n,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:t}))),a=r.findIndex(n=>n==null);if(a>-1)throw new F("imagery-tile-layer:open",`cannot open raster: ${i[a]}`);return this._primaryRasters=r,this._initializeWithFunctionRaster(e)}async _openFromUrl(s,e){const t=await de.open({url:s,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:e});if(t==null)throw new F("imagery-tile-layer:open",`cannot open raster: ${s}`);this._primaryRasters=[t],this.raster=t}async _openFromSource(s,e){var a;const t="the tiled imagery data source is not supported",i=((a=s.type)==null?void 0:a.toLowerCase())==="coverage"?"CovJSON":s.extent&&s.pixelBlock?"MEMORY":null;if(!i)throw new F("imagery-tile-layer:open",t);i==="MEMORY"&&(s={...s,pixelBlock:void 0,pixelBlocks:[s.pixelBlock]});const r=await de.open({url:"",source:s,datasetFormat:i,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:e});if(r==null)throw new F("imagery-tile-layer:open",t);this._primaryRasters=[r],this.rasterFunction?await this._initializeWithFunctionRaster(this.rasterFunction):this.raster=r}async _openFunctionRaster(s,e){var a;const t={raster:this._primaryRasters[0]};this._primaryRasters.length>1&&this._primaryRasters.forEach(n=>t[n.url]=n);const i=Ht(((a=s.functionDefinition)==null?void 0:a.toJSON())??s.toJSON(),t),r=new it({rasterFunction:i});return await r.open(e),r}async _initializeWithFunctionRaster(s,e){try{this.raster=await this._openFunctionRaster(s,e)}catch(t){t instanceof F&&ge.getLogger(this).error("imagery-tile-layer:open",t.message),ge.getLogger(this).warn("imagery-tile-layer:open","the raster function cannot be applied and is removed"),this._set("rasterFunction",null),this.raster=this._primaryRasters[0]}}};R([C({clonable:!1})],N.prototype,"_primaryRasters",void 0),R([C(at)],N.prototype,"legendEnabled",void 0),R([C({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],N.prototype,"isReference",void 0),R([C({type:["show","hide"]})],N.prototype,"listMode",void 0),R([C({json:{read:!0,write:!0}})],N.prototype,"blendMode",void 0),R([C({type:Me,json:{name:"renderingRule",write:!0}})],N.prototype,"rasterFunction",void 0),R([C()],N.prototype,"sourceJSON",void 0),R([C({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],N.prototype,"version",void 0),R([C({readOnly:!0,json:{read:!1}})],N.prototype,"type",void 0),R([C({type:["ArcGISTiledImageServiceLayer"]})],N.prototype,"operationalLayerType",void 0),R([C({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(s,e)=>!e.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}},writer(s,e,t){e[t]=!s}}}})],N.prototype,"popupEnabled",void 0),R([C({type:Xe,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}}}}})],N.prototype,"popupTemplate",void 0),R([C({readOnly:!0})],N.prototype,"defaultPopupTemplate",null),R([C({readOnly:!0,type:[Te]})],N.prototype,"fields",void 0),R([C({readOnly:!0,type:[Te]})],N.prototype,"rasterFields",null),R([C({constructOnly:!0})],N.prototype,"source",void 0),N=R([Y("esri.layers.ImageryTileLayer")],N);const Qi=N;export{Qi as default};
